DATA SEGMENT
INFO1 DB 'Input a score, and press ENTER to input next score or SPACE to finish',10,13,'$'
INFO2 DB 10,13,'The data has been analyzed, and the result is:',10,13,'$'
INFO3 DB 10,13,'60~69:',10,13,'$'
INFO4 DB 10,13,'70~79:',10,13,'$'
INFO5 DB 10,13,'80~89:',10,13,'$'
INFO6 DB 10,13,'90~99:',10,13,'$'
INFO7 DB 10,13,'100:',10,13,'$'
INFO8 DB '10$'
SCORE6 DB '0'
SCORE7 DB '0'
SCORE8 DB '0'
SCORE9 DB '0'
SCORE10 DB '0'
DATA ENDS


STACKS SEGMENT
DB 100 DUP(?)
STACKS ENDS

CODES SEGMENT
ASSUME CS:CODES,DS:DATA,SS:STACKS
START:
MOV AX,DATA
MOV DS,AX ;段寄存器初始化
NEXT:
LEA DX,INFO1
MOV AH,09
INT 21H ;提示输入
NEXT1:
XOR DH,DH
MOV AH,01
INT 21H
CMP AL,20H
JE DISPLAY ;若输入空格则进入显示结果环节
CMP AL,13
JE COUNT ;若输入回车进入计数环节
MOV DH,AL
MOV AL,DL
MOV BX,10
MUL BL
MOV DL,AL ;以上几步对第n-1步(DL)乘10
SUB DH,30H
ADD DL,DH ;将第n步输入的值加到(DL)，循环操作实现字符到数据转换
XOR DH,DH
PUSH DX ;DX入栈存放
JMP NEXT1 ;继续进行成绩低一位数输入

COUNT:
POP DX ;取出最后入栈的DX，COUNT部分通过分支跳转实现成绩统计
CMP DL,100
JE SC10
CMP DL,70
JB SC6
CMP DL,80
JB SC7
CMP DL,90
JB SC8
JMP SC9

SC6:
ADD [SCORE6],1
JMP NEXT
SC7:
ADD [SCORE7],1
JMP NEXT
SC8:
ADD [SCORE8],1
JMP NEXT
SC9:
ADD [SCORE9],1
JMP NEXT
SC10:
ADD [SCORE10],1
JMP NEXT ;SC6~SC10实现了成绩统计，计入一个成绩后返回等待下一个成绩输入

DISPLAY:
LEA DX,INFO3
MOV AH,9
INT 21H ;显示提示字符串
MOV DL,[SCORE6]
CMP DL,3AH
JNE GO1 ;不为10直接在GO1环节显示输出单个字符即可
LEA DX,INFO8
MOV AH,9
INT 21H
JMP NEX1 ;这里实现对10的正确显示，这与个位数的处理不同
GO1:MOV AH,2
INT 21H ;对单个字符的显示
NEX1:LEA DX,INFO4 ;下面对其他分数段的显示原理与60~69完全相同，不再赘述
MOV AH,9
INT 21H
MOV DL,[SCORE7]
CMP DL,3AH
JNE GO2
LEA DX,INFO8
MOV AH,9
INT 21H
JMP NEX2
GO2:MOV AH,2
INT 21H
NEX2:LEA DX,INFO5
MOV AH,9
INT 21H
MOV DL,[SCORE8]
CMP DL,3AH
JNE GO3
LEA DX,INFO8
MOV AH,9
INT 21H
JMP NEX3
GO3:MOV AH,2
INT 21H
NEX3:LEA DX,INFO6
MOV AH,9
INT 21H
MOV DL,[SCORE9]
CMP DL,3AH
JNE GO4
LEA DX,INFO8
MOV AH,9
INT 21H
JMP NEX4
GO4:MOV AH,2
INT 21H
NEX4:LEA DX,INFO7
MOV AH,9
INT 21H
MOV DL,[SCORE10]
CMP DL,3AH
JNE GO5
LEA DX,INFO8
MOV AH,9
INT 21H
JMP NEX5
GO5:MOV AH,2
INT 21H
NEX5:MOV AH,4CH
INT 21H
CODES ENDS
END START